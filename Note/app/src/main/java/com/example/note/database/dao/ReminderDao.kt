package com.example.note.database.dao

import android.util.Log
import androidx.lifecycle.LiveData
import androidx.room.*
import com.example.note.database.entities.BaseEntity
import com.example.note.database.entities.Reminder
import com.example.note.toPrettyString
import io.ktor.client.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

@Dao // [D]ata [A]ccess [O]bjects
interface ReminderDao : BaseDao {

    /*****************************************************************************
     * Methods auto-generated by Room
     ****************************************************************************/

    // https://developer.android.com/training/data-storage/room/accessing-data#convenience-update
    // Room uses the primary key to match passed entity instances to rows
    // in the database. If there is no row with the same primary key,
    // Room makes no changes.

    @Insert(onConflict = OnConflictStrategy.ABORT)
    fun insert(reminder: Reminder): Long

    @Insert(onConflict = OnConflictStrategy.ABORT)
    fun insertAll(vararg reminders: Reminder)

    @Delete
    fun delete(reminder: Reminder)

    @Delete
    fun deleteAll(vararg reminders: Reminder)

    @Update
    fun update(reminder: Reminder)

    @Update
    fun updateAll(vararg reminders: Reminder)

    /*****************************************************************************
     * Methods defined by user
     ****************************************************************************/

    @Query("DELETE FROM reminders")
    override fun clear()

    @Query("DELETE FROM reminders WHERE noteID = :noteID")
    fun deleteRemindersByNoteID(noteID: Int)

    @Query("UPDATE reminders SET noteID = :newID WHERE noteID = :oldID")
    fun updateRemindersNoteIDByNoteID(oldID: Int, newID: Int)

    // Ascending order
    @Query("SELECT * FROM reminders ORDER BY id ASC")
    fun getAllReminders(): LiveData<List<Reminder>>

    @Query("SELECT * FROM reminders WHERE noteID = :noteID ORDER BY id ASC")
    fun getRemindersByNoteID(noteID: Int): LiveData<List<Reminder>>

    @Query("SELECT id FROM reminders WHERE noteID = :noteID ORDER BY id ASC")
    fun getReminderIDsByNoteID(noteID: Int): List<Int>

    @Query("SELECT * FROM reminders WHERE id = :reminderID")
    fun getReminderByID(reminderID: Int): Reminder

    @Query("SELECT body FROM reminders WHERE id = :id")
    fun getReminderBodyByID(id: Int): String

    @Query("SELECT time FROM reminders WHERE id = :id")
    fun getReminderTimeByID(id: Int): String

    @Query("SELECT reminderOff FROM reminders WHERE id = :id")
    fun getReminderStateByID(id: Int): Boolean

    @Query("SELECT count(*) FROM reminders")
    fun getAllRemindersCount(): Int

    @Query("SELECT count(*) FROM reminders WHERE noteID = :noteID")
    fun getRemindersCountByNoteID(noteID: Int): Int

    @Query("UPDATE reminders SET noteID = :noteID WHERE id = :reminderID")
    fun updateNoteIDByReminderID(noteID: Int, reminderID: Int)

    override fun pullFromServer(baseURL: String) {
        // Clear all local reminders
        clear()

        // Fetch reminders from server
        var reminders: List<Reminder>? = null
        runBlocking {
            launch {
                reminders = Json.decodeFromString(HttpClient().get("$baseURL/reminders"))
            }
        }

        // Update reminders if non-null
        if (reminders != null) {
            Log.d("ReminderDao", "Received reminders from server: ${reminders!!.toPrettyString()}")
            insertAll(*(reminders!!.toTypedArray()))
        } else {
            Log.e("ReminderDao", "Fetching reminders from server failed, received null!!!")
        }
    }
}

fun ReminderDao.pushToServer(item: BaseEntity, operation: BaseDao.OPERATION, baseURL: String) {
    if (item !is Reminder) {
        Log.e("ReminderDao", "Received item is of BaseEntity but not a reminder!!!")
        return
    } else {
        Log.d("ReminderDao", "Received reminder \"$item\" with operation \"${operation.name}\", " +
            "trying pushing to server at endpoint \"$baseURL\"")
    }
    val ENDPOINT = baseURL + when (operation) {
        BaseDao.OPERATION.INSERT -> "/reminders"
        BaseDao.OPERATION.MULTIPLE_DELETE -> "/reminders?noteID=${item.noteID}"
        else -> "/reminders/${item.id}"
    }.also {
        Log.d("ReminderDao", "Pushing to endpoint \"$it\"")
    }

    CoroutineScope(Dispatchers.IO).launch {
        try {
            val response: HttpResponse = HttpClient().request(ENDPOINT) {
                method = when (operation) {
                    BaseDao.OPERATION.INSERT -> HttpMethod.Post
                    BaseDao.OPERATION.UPDATE -> HttpMethod.Put
                    BaseDao.OPERATION.DELETE,
                    BaseDao.OPERATION.MULTIPLE_DELETE -> HttpMethod.Delete
                }
                contentType(ContentType.Application.Json)
                body = Json.encodeToString(item)
            }
            if (response.status != HttpStatusCode.OK) {
                Log.e("ReminderDao", "Get response's status code ${response.status}!!!")
            }
        } catch (e: Exception) {
            Log.e("ReminderDao", "Exception when sending request to server!!!")
            e.printStackTrace()
        }
    }

    Log.d("ReminderDao", "Successfully pushed operation \"${operation.name}\" to server")
}